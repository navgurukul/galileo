{
  "_args": [
    [
      {
        "raw": "gulp-env@^0.4.0",
        "scope": null,
        "escapedName": "gulp-env",
        "name": "gulp-env",
        "rawSpec": "^0.4.0",
        "spec": ">=0.4.0 <0.5.0",
        "type": "range"
      },
      "/home/arch/galileo"
    ]
  ],
  "_from": "gulp-env@>=0.4.0 <0.5.0",
  "_id": "gulp-env@0.4.0",
  "_inCache": true,
  "_location": "/gulp-env",
  "_nodeVersion": "5.1.1",
  "_npmUser": {
    "name": "russmatney",
    "email": "russell.matney@gmail.com"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "raw": "gulp-env@^0.4.0",
    "scope": null,
    "escapedName": "gulp-env",
    "name": "gulp-env",
    "rawSpec": "^0.4.0",
    "spec": ">=0.4.0 <0.5.0",
    "type": "range"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/gulp-env/-/gulp-env-0.4.0.tgz",
  "_shasum": "8370646949a32493dc06dad94a0643296faadbe8",
  "_shrinkwrap": null,
  "_spec": "gulp-env@^0.4.0",
  "_where": "/home/arch/galileo",
  "bugs": {
    "url": "https://github.com/crystalschang/gulp-env/issues"
  },
  "contributors": [
    {
      "name": "Moveline"
    },
    {
      "name": "Isiah Meadows",
      "email": "isiahmeadows@gmail.com",
      "url": "https://github.com/impinball"
    },
    {
      "name": "Russell Matney",
      "url": "https://github.com/russmatney"
    }
  ],
  "dependencies": {
    "ini": "^1.3.4",
    "through2": "^2.0.0"
  },
  "description": "Add env vars to your process.env",
  "devDependencies": {
    "chai": "^1.9.1",
    "gulp": "^3.9.0",
    "mocha": "^1.21.4"
  },
  "directories": {},
  "dist": {
    "shasum": "8370646949a32493dc06dad94a0643296faadbe8",
    "tarball": "https://registry.npmjs.org/gulp-env/-/gulp-env-0.4.0.tgz"
  },
  "gitHead": "531cf48f538e17c6ee9d40852cca2bf19a87c86a",
  "homepage": "https://github.com/crystalschang/gulp-env",
  "keywords": [
    "gulp",
    "gulp-env",
    "env",
    "process.env",
    "gulpfriendly"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "russmatney",
      "email": "russell.matney@gmail.com"
    }
  ],
  "name": "gulp-env",
  "optionalDependencies": {},
  "readme": "gulp-env\n========\n\nAdd or modify variables in your `process.env`.\n\nPurpose\n========\n\nOften, two processes running at the same time need different environmental variables (for example: running tests and a server from the same gulp process). `gulp-env` helps simplify that problem, by letting you establish your env vars whenever you'd like, in a simpler interface. You can set values from an external `.json`, `.ini`, or other file, or programmatically set them directly by using `env({vars:{}})` or `env.set(vars)`.\n\nInstall\n========\n\n```\nnpm i --save-dev gulp-env\n```\n\nThe TypeScript definition file is available in gulp-env.d.ts within the base directory.\n\nUsage\n======\n\n### Example\n\nNodemon server:\n\n```js\n// gulpfile.js\nvar gulp = require('gulp');\nvar nodemon = require('gulp-nodemon');\nvar env = require('gulp-env');\n\ngulp.task('nodemon', function() {\n  env({\n    file: '.env.json',\n    vars: {\n      // any variables you want to overwrite\n    }\n  });\n\n  nodemon({\n    script: 'server.js',\n    ext: 'js html'\n    // other config ...\n  });\n});\n\ngulp.task('default', ['nodemon']);\n```\n\nES6 web development:\n\n```js\nimport gulp from 'gulp';\nimport browserify from 'browserify';\nimport transform from 'vinyl-transform';\nimport babel from 'gulp-babel';\nimport concat from 'gulp-concat';\nimport jshint from 'gulp-jshint';\nimport uglify from 'gulp-uglify';\nimport sourcemaps from 'gulp-sourcemaps';\n\ngulp.task('debug', () => {\n  const envs = env.set({\n    NODE_ENV: 'debug'\n  });\n  return gulp.src('src/main.js')\n    .pipe(envs)\n    .pipe(babel({optional: [\n      'utility.inlineEnvironmentVariables'\n    ]}))\n    .pipe(uglify())\n    .pipe(transform(file => browserify(file).bundle()))\n    .pipe(envs.reset)\n    .pipe(gulp.dest('dist'));\n});\n```\n\nSimple CoffeeScript library's gulpfile:\n\n```coffee\ngulp = require 'gulp'\ncoffee = require 'gulp-coffee'\nmocha = require 'gulp-mocha'\nenv = require 'gulp-env'\nCSON = require 'cson-safe'\n\ngulp.task 'compile', ->\n  gulp.src('src')\n    .pipe coffee()\n    .pipe gulp.dest('dest')\n\ngulp.task 'test', ['compile'], ->\n  gulp.src('test')\n    .pipe envs = env\n      file: 'config.cson'\n      handler: CSON.parse\n    .pipe mocha()\n    .pipe envs.reset\n```\n\n## Details\n\n`gulp-env` has full test coverage for JSON files, JS modules, INI files, and custom handlers. The entire API below is covered as well. It can also be used in the middle of a Gulp pipeline, where this returns a no-op stream. Note that the `process.env` changes happen synchronously, at the time when the function is called.\n\nRead a file and set `process.env` accordingly. Both of these forms are equivalent.\n\n```js\nenv(file: string) => EnvStream\nenv({file: string}) => EnvStream\n```\n\nSet one or more hardcoded values in `process.env` directly.\n\n```js\nenv({vars: Object}) => EnvStream\nenv.set(vars: Object) => EnvStream\n```\n\nParse a file, overriding some of its variables.\n\n```js\nenv({\n  // file to read\n  file: string,\n\n  // overrides\n  vars: Object,\n}) => EnvStream\n```\n\nParse a file with a custom parser.\n\n```js\nenv({\n  // file to read\n  file: string,\n\n  // custom handling, `contents` is the file's contents\n  handler: (contents: string) => Object,\n\n  // optional overrides\n  vars?: Object,\n}) => EnvStream\n```\n\nParse a file as a different type.\n\n```js\nenv({\n  // file to read\n  file: string,\n\n  // Treat it like this type. See `options.type` for limitations.\n  type: string,\n\n  // overrides\n  vars?: Object,\n}) => EnvStream\n```\n\n### `file`, `options.file`\n\nThe `file` option loads the file's contents automatically, calling `require` if it isn't a `.ini` file or if there is no `handler`. You can omit the extension as far as `require` allows if it's already registered, since this uses `require` under the hood as a fallback.\n\n```js\n// .env.json\n{\n  MONGO_URI: \"mongodb://localhost:27017/testdb\"\n}\n\n// .env.js\nmodule.exports = {\n  MONGO_URI: \"mongodb://localhost:27017/testdb\",\n};\n\n// gulpfile.js\nvar env = require('gulp-env');\n\nprocess.env.MONGO_URI === \"mongodb://localhost:27017/testdb\"; // maybe false\n\n// Any of these will work:\nenv(\".env\"); // if the file can be found via `require`\nenv(\".env.json\");\nenv({file: \".env\"}); // if the file can be found via `require`\nenv({file: \".env.json\"});\n\nprocess.env.MONGO_URI === \"mongodb://localhost:27017/testdb\"; // true\n```\n\n### `options.vars`\n\nProperties on this object overwrite all existing external properties given by file loading, handlers, etc. All of these will also be added to `process.env`.\n\n```js\n// gulpfile.js\nvar env = require('gulp-env');\nenv({\n  file: 'env.ini',\n  vars: {\n    MONGO_URI: \"mongodb://localhost:27017/testdb-for-british-eyes-only\",\n    PORT: 9001\n  }\n});\n```\n\nFor the case of just setting environment variables programmatically, you can use `env.set`.\n\n```js\n// These two are equivalent. They both can also be used in Gulp streams.\nenv({vars: vars});\nenv.set(vars);\n```\n\n### `options.handler`\n\nThis customizes the parsing of the file. If this is given, the extension name is ignored, and the handler itself is directly called. This is very useful in cases where this module doesn't already support the format. Internally, the module uses this hook for its INI and JSON readers.\n\nThe function, if given, is called with two arguments:\n\n- `contents` - the file's contents\n- `filename` - the file's name\n\nNotes:\n\n- You don't need this if the file type itself is already registered in `require.extensions`.\n- If the file doesn't exist, then `contents` is undefined. `filename` is still passed, though.\n- If the extension is omitted, then `filename` reflects that, i.e. the extension is omitted.\n\n```coffee\n# CSON is frequently used in CoffeeScript projects. Why not use that?\nenv = require 'gulp-env'\nCSON = require 'cson-safe'\n\nenv\n  file: '.env.cson'\n  handler: (contents) -> CSON.parse contents\n```\n\n```js\n// Or, why can't we use YAML?\nvar env = require('gulp-env');\nvar jsyaml = require('js-yaml');\n\nenv({\n  file: '.env.yaml',\n  handler: function(contents, filename) {\n    return jsyaml.safeLoad(contents, {filename: filename});\n  },\n});\n```\n\n### `options.type`\n\nTreats the file input as if its extension was `type`. It doesn't work for `require`d files, since Node.js doesn't have hooks to do that, but it currently works for `json` and `ini` types. Others may potentially be added over time. If you think another one should be added, please, by all means, submit a PR.\n\n```js\nvar env = require('gulp-env');\n\nenv({\n  file: '.env',\n  type: 'ini',\n});\n\n// You can also specify it as an extension, as opposed to a type.\nenv({\n  file: '.env',\n  type: '.ini',\n});\n```\n\n### EnvStream\n\nInstances of this interface are returned for `env()` and `env.set()`. These are standard through2 object streams with the following extra methods:\n\n- Reset the environment to its former state synchronously. This is designed to be most useful outside of gulpfiles. It returns a boolean, true if any properties were reset, false otherwise. Pass a truthy value as an argument to forcefully restore, i.e. ignore conflicts.\n\n  ```js\n  envs.restore(force?: boolean) => boolean\n  ```\n\n- Reset the environment to its former state. Similar to `.restore()`, but is called after the incoming stream is flushed, i.e. after all previous Gulp plugins have had their effect on the stream. This is otherwise a no-op through2 object stream. The second version is analogous to `envs.restore(true)`\n\n  ```js\n  envs.reset => stream.Readable, stream.Writable\n  envs.reset.force => stream.Readable, stream.Writable\n  ```\n\nNote that such environments can be nested. For example, the following will work:\n\n```js\nprocess.env.NODE_ENV // undefined\nvar env1 = env.set({NODE_ENV: \"whatever\"});\nprocess.env.NODE_ENV // \"whatever\"\nvar env2 = env.set({NODE_ENV: \"something else\"});\nprocess.env.NODE_ENV // \"something else\"\nenv2.restore();\nprocess.env.NODE_ENV // \"whatever\"\nenv1.restore();\nprocess.env.NODE_ENV // undefined\n```\n\nNow, if two settings are restored out of order, conflicting keys (where the currently set value is not the same as the originally set for that version) are simply left as-is. This is the same with externally changed environment variables.\n\n```js\n// unbalanced modifications\nprocess.env.NODE_ENV // undefined\nvar env1 = env.set({NODE_ENV: \"whatever\"});\nprocess.env.NODE_ENV // \"whatever\"\nvar env2 = env.set({NODE_ENV: \"something else\"});\nprocess.env.NODE_ENV // \"something else\"\nenv1.restore();\nprocess.env.NODE_ENV // \"something else\"\nenv2.restore();\nprocess.env.NODE_ENV // \"whatever\"\n\n// external modifications\nprocess.env.NODE_ENV // undefined\nvar env1 = env.set({NODE_ENV: \"whatever\"});\nprocess.env.NODE_ENV // \"whatever\"\nprocess.env.NODE_ENV = \"something else\";\nenv1.restore();\nprocess.env.NODE_ENV // \"something else\"\n```\n\nIssues\n=======\n\nSubmit a new issue here in the [issue tracker](https://github.com/moveline/gulp-env/issues/new)\n\nContributing\n=============\n\nThis aims for full test coverage. If you see something missing, please, by all means, [send a PR](https://github.com/moveline/gulp-env/compare).\n\nTo run the tests, run `npm test`. The tests and their dependencies are written in `test/**`.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/crystalschang/gulp-env.git"
  },
  "scripts": {
    "test": "mocha test/*.js"
  },
  "typescript": {
    "definition": "./gulp-env.d.ts"
  },
  "version": "0.4.0"
}
